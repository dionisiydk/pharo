Class {
	#name : #ProcessMonitorTestServiceTest,
	#superclass : #TestExecutionEnvironmentTestCase,
	#category : #'SUnit-Tests-Core'
}

{ #category : #running }
ProcessMonitorTestServiceTest >> createTestService [

	^ProcessMonitorTestService new
]

{ #category : #running }
ProcessMonitorTestServiceTest >> fork: aBlock [
	"Here we simulate fork under TestExecutionEnvironment 
	which passes new process to all test services"
	| newProcess |
	newProcess := self newProcess: 'Test process' toImmediatelyExecute: aBlock.
	testService handleNewProcess: newProcess.
	newProcess resume.
	^newProcess
]

{ #category : #running }
ProcessMonitorTestServiceTest >> setUp [ 
	super setUp.
	
	"Following settings ensure that we are testing full behavior independently from default settings"
	testService failTestLeavingProcesses. 
	testService terminateProcessesAfterTest.
	executionEnvironment activated 
]

{ #category : #tests }
ProcessMonitorTestServiceTest >> testAllowRunningBackgroundProcessesToFinish [

	| semaphore processIsDone process |
	semaphore := Semaphore new.
	processIsDone := false.
	process := self fork: [ semaphore wait. processIsDone := true].
	process priority: Processor activePriority.
	semaphore signal.
	self deny: processIsDone.
	
	testService handleCompletedTest.
	
	self assert: processIsDone.
]

{ #category : #tests }
ProcessMonitorTestServiceTest >> testAllowRunningBackgroundProcessesToFinishButFailTestIfItCant [

	| semaphore process wasResumed |
	semaphore := Semaphore new.
	wasResumed := false.
	process := self fork: [ semaphore wait. wasResumed := true. 10 seconds wait].
	process priority: Processor activePriority.
	semaphore signal.
	self deny: wasResumed.
	
	self should: [testService handleCompletedTest] raise: TestLeftRunningProcess.
	self assert: wasResumed
]

{ #category : #tests }
ProcessMonitorTestServiceTest >> testAlwaysPassBackgroundHalt [
	| process haltWasPassed halt |
	
	haltWasPassed := false.
	halt := Halt new.
	process := self fork: [ Processor activeProcess suspend. halt signal ].
	testService handleNewProcess: process.
	
	process on: Halt do: [ :actual | 
		actual == halt ifFalse: [ actual pass ]. "it allows to debug if it works wrongly"
		self assert: actual equals: halt. haltWasPassed := true ].
	process resume.
	
	self assert: haltWasPassed.
	self assert: process isTerminated description: 'process should be terminated now'. 
	self deny: (testService suspendedBackgroundFailures includesKey: process)
]

{ #category : #tests }
ProcessMonitorTestServiceTest >> testCleanUpShouldNotTerminateAllFailedProcessesWhenSuchTerminationIsDisabled [
	| process  |
	process := self fork: [ testService suspendBackgroundFailure: Error new ].
	testService disableProcessesTermination.
	
	testService cleanUpAfterTest.
	
	self deny: process isTerminated.		
	self assert: testService suspendedBackgroundFailures isEmpty.
	self assert: testService forkedProcesses isEmpty
]

{ #category : #tests }
ProcessMonitorTestServiceTest >> testCleanUpShouldNotTerminateAllRunningProcessesWhenSuchTerminationIsDisabled [
	| process  |
	process := self fork: [ 10 seconds wait ].
	testService disableProcessesTermination.
	
	testService cleanUpAfterTest.
	
	self deny: process isTerminated.		
	self assert: testService forkedProcesses isEmpty
]

{ #category : #tests }
ProcessMonitorTestServiceTest >> testCleanUpShouldRestoreDefaultFailingLogicForRunningProcessesCase [

	testService shouldFailTestLeavingProcesses: ProcessMonitorTestService shouldFailTestLeavingProcesses not.
	
	testService cleanUpAfterTest.
	
	self assert: testService shouldFailTestLeavingProcesses equals: ProcessMonitorTestService shouldFailTestLeavingProcesses.
]

{ #category : #tests }
ProcessMonitorTestServiceTest >> testCleanUpShouldRestoreProcessTerminationLogic [

	testService shouldTerminateProcesses: ProcessMonitorTestService shouldTerminateProcesses not.
	
	testService cleanUpAfterTest.
	
	self assert: testService shouldTerminateProcesses equals: ProcessMonitorTestService shouldTerminateProcesses.
]

{ #category : #tests }
ProcessMonitorTestServiceTest >> testCleanUpShouldRestoreSuspensionLogic [

	testService passBackgroundFailures.
	self deny: testService shouldSuspendBackgroundFailures.
	
	testService cleanUpAfterTest.
	self assert: testService shouldSuspendBackgroundFailures
]

{ #category : #tests }
ProcessMonitorTestServiceTest >> testCleanUpShouldTerminateAllFailedProcesses [
	| process  |
	process := self fork: [ testService suspendBackgroundFailure: Error new ].
	
	testService cleanUpAfterTest.
	
	self assert: process isTerminated.		
	self assert: testService suspendedBackgroundFailures isEmpty.
	self assert: testService forkedProcesses isEmpty
]

{ #category : #tests }
ProcessMonitorTestServiceTest >> testCleanUpShouldTerminateAllRunningProcesses [
	| process  |
	process := self fork: [ 10 seconds wait ].
	
	testService cleanUpAfterTest.
	
	self assert: process isTerminated.		
	self assert: testService forkedProcesses isEmpty
]

{ #category : #tests }
ProcessMonitorTestServiceTest >> testDisableRunningProcessesCleanupWhenPassBackgroundFailures [

	testService passBackgroundFailures.
	
	self deny: testService shouldTerminateProcesses
]

{ #category : #tests }
ProcessMonitorTestServiceTest >> testDoesNotRaiseForkedProcessFailureWhenFailuresWerePassedAndMainProcessAlsoFails [

	self fork: [ testService suspendBackgroundFailure: Error new. 
		Processor activeProcess suspend "To emulate process under debugger" ].

	testService passBackgroundFailures.
	testService recordTestFailure: Error new.	
		
	self shouldnt: [testService handleCompletedTest] raise: TestFailedByForkedProcess
]

{ #category : #tests }
ProcessMonitorTestServiceTest >> testDoesNotRaiseForkedProcessFailureWhenFailuresWerePassedAndProcessCompletes [

	| process |
	process := self fork: [ testService suspendBackgroundFailure: Error new ].
	
	testService passBackgroundFailures.
	
	self assert: process isTerminated description: 'process should be terminated now'.
	self shouldnt: [testService handleCompletedTest] raise: TestFailedByForkedProcess
]

{ #category : #tests }
ProcessMonitorTestServiceTest >> testDoesNotRaiseForkedProcessFailureWhenThereWasOnlyMainProcessFailure [

	testService handleException: Error new.
	
	self shouldnt: [testService handleCompletedTest] raise: TestFailedByForkedProcess
]

{ #category : #tests }
ProcessMonitorTestServiceTest >> testDoesNotRaiseLeftRunningProcessWhenItAllowsThemToBe [

	| process |
	process := self fork: [ 10 seconds wait ].
	self deny: process isTerminated.

	testService allowTestToLeaveProcesses.	
	self shouldnt: [testService handleCompletedTest] raise: TestLeftRunningProcess.
	self deny: process isTerminated.
]

{ #category : #tests }
ProcessMonitorTestServiceTest >> testDoesNotRaiseLeftRunningProcessWhenProcessWasOnlyCreated [

	testService handleNewProcess: [  ] newProcess.
	
	self shouldnt: [testService handleCompletedTest] raise: TestLeftRunningProcess 
]

{ #category : #tests }
ProcessMonitorTestServiceTest >> testDoesNotRaiseLeftRunningProcessWhenThereWasMainProcessFailure [

	self fork: [ 10 seconds wait].
	
	testService handleException: Error new.
	
	self shouldnt: [testService handleCompletedTest] raise: TestLeftRunningProcess
]

{ #category : #tests }
ProcessMonitorTestServiceTest >> testFailTestWhenBackgroundFailureWasPassedButMainProcessCompletesSuccessfully [

	self fork: [ testService suspendBackgroundFailure: Error new. 
		Processor activeProcess suspend "To emulate process under debugger" ].
	
	testService passBackgroundFailures.
	
	self should: [testService handleCompletedTest] raise: TestFailedByForkedProcess
]

{ #category : #tests }
ProcessMonitorTestServiceTest >> testFailTestWhenBackgroundProcessWasFailedDuringFinalTryToFinishItAtTestCompletionTime [

	| semaphore processIsDone process |
	semaphore := Semaphore new.
	processIsDone := false.
	process := self fork: [ semaphore wait. processIsDone := true. 1/0 ].
	process priority: Processor activePriority.
	semaphore signal.
	self deny: processIsDone.
	
	self should: [testService handleCompletedTest] raise: TestFailedByForkedProcess.	
	self assert: processIsDone.
]

{ #category : #tests }
ProcessMonitorTestServiceTest >> testFailTestWhenItIsCompletedWithBackgroundFailures [

	self fork: [ testService suspendBackgroundFailure: Error new ].
	
	self should: [testService handleCompletedTest] raise: TestFailedByForkedProcess
]

{ #category : #tests }
ProcessMonitorTestServiceTest >> testFailTestWhenItIsCompletedWithBackgroundFailuresAndRunningProcesses [

	self fork: [ testService suspendBackgroundFailure: Error new ].
	self fork: [ 10 seconds wait ].
	
	self 
		should: [
			[testService handleCompletedTest] 
				on: TestFailedByForkedProcess do: [ :err | err resumeUnchecked: true ]]
		raise: TestLeftRunningProcess
]

{ #category : #tests }
ProcessMonitorTestServiceTest >> testFailTestWhenItIsCompletedWithRunningProcesses [

	self fork: [ 10 seconds wait ].
	
	self should: [testService handleCompletedTest] raise: TestLeftRunningProcess
]

{ #category : #tests }
ProcessMonitorTestServiceTest >> testGettingFailuresFromEnvironment [

	self assert: executionEnvironment failures equals: testService testFailures
]

{ #category : #tests }
ProcessMonitorTestServiceTest >> testGettingForkedProcessesFromEnvironment [

	self assert: executionEnvironment forkedProcesses equals: testService forkedProcesses
]

{ #category : #tests }
ProcessMonitorTestServiceTest >> testGettingServiceFromEnvironment [

	self assert: executionEnvironment processMonitor identicalTo: testService 
]

{ #category : #tests }
ProcessMonitorTestServiceTest >> testGettingServiceFromTestCase [

	| actual |
	executionEnvironment beActiveDuring: [ 
		actual := self executionProcessMonitor
	].

	self assert: actual identicalTo: testService 
]

{ #category : #tests }
ProcessMonitorTestServiceTest >> testHasDefaultFailingStrategyForRunningProcesses [

	testService := ProcessMonitorTestService new.
	
	self assert: testService shouldFailTestLeavingProcesses notNil.
	self assert: testService shouldFailTestLeavingProcesses equals: ProcessMonitorTestService shouldFailTestLeavingProcesses.
]

{ #category : #tests }
ProcessMonitorTestServiceTest >> testHasDefaultTerminationStrategyForRunningProcesses [

	testService := ProcessMonitorTestService new.
	
	self assert: testService shouldTerminateProcesses notNil.
	self assert: testService shouldTerminateProcesses equals: ProcessMonitorTestService shouldTerminateProcesses
]

{ #category : #tests }
ProcessMonitorTestServiceTest >> testHasEmptyForkedProcessesByDefault [

	self assert: testService forkedProcesses isEmpty
]

{ #category : #tests }
ProcessMonitorTestServiceTest >> testHasEmptySuspendedBackgroundFailuresByDefault [

	self assert: testService suspendedBackgroundFailures isEmpty
]

{ #category : #tests }
ProcessMonitorTestServiceTest >> testIgnoreDirtyTestErrors [
	
	testService handleException: TestLeftRunningProcess new.
	self assert: testService testFailures isEmpty.
	
	testService handleException: TestFailedByForkedProcess new.
	self assert: testService testFailures isEmpty
]

{ #category : #tests }
ProcessMonitorTestServiceTest >> testIsMainTestProcessFailed [

	executionEnvironment activated.
	
	self deny: testService isMainTestProcessFailed.
	
	testService recordTestFailure: Error new.
	self assert: executionEnvironment isMainTestProcessFailed
]

{ #category : #tests }
ProcessMonitorTestServiceTest >> testIsTestProcessFailed [

	| process |
	self deny: (testService isTestProcessFailed: #process).
	
	process := self fork: [testService recordTestFailure: Error new].
	self assert: (testService isTestProcessFailed: process).
	self deny: (testService isTestProcessFailed: #anotherProcess)
]

{ #category : #tests }
ProcessMonitorTestServiceTest >> testPassBackgroundFailuresWhenSuspensionLogicIsDisabled [
	| process error errorWasPassed |
	errorWasPassed := false.
	error := Error new messageText: 'test error'.
	process := self fork: [ Processor activeProcess suspend. error signal ].	
	
	testService disableBackgroudFailuresSuspension.
	self deny: testService shouldSuspendBackgroundFailures.
	
	process on: UnhandledError do: [ :err | errorWasPassed := true ].
	process resume.
	
	self assert: errorWasPassed.
	self assert: process isTerminated description: 'process should be terminated now'
]

{ #category : #tests }
ProcessMonitorTestServiceTest >> testRecordMainTestProcessError [

	| error |
	error := Error new.
	
	testService handleException: error.

	self 
		assert: (testService testFailures at: Processor activeProcess) 
		equals: error
]

{ #category : #tests }
ProcessMonitorTestServiceTest >> testRecordMainTestProcessUnhandledError [

	| error |
	error := UnhandledError new.
	
	testService handleException: error.

	self 
		assert: (testService testFailures at: Processor activeProcess) 
		equals: error
]

{ #category : #tests }
ProcessMonitorTestServiceTest >> testResumeFailedProcessWhenItFailsTestWithUnhandledError [
	"Test with background failures is failing with TestFailedByForkedProcess.
	In case when it is unhandled (when we debug the test) it should resume all background failures"
	| executed failedProcess |
	executed := false.
	failedProcess := self fork: [testService suspendBackgroundFailure: Error new. executed := true ].
	self assert: failedProcess isSuspended.
	
	self runWithNoHandlers: [
		[testService handleCompletedTest] on: UnhandledError do: [ :err |
			self deny: failedProcess isSuspended]
	].

	self assert: executed 
]

{ #category : #tests }
ProcessMonitorTestServiceTest >> testResumeFailedProcessesWhenHaltIsSignaled [
	| executed |
	executed := false.
	self fork: [ testService suspendBackgroundFailure: Error new. executed := true ].

	testService handleException: Halt new. 
	
	self assert: executed.
	self deny: testService shouldSuspendBackgroundFailures
]

{ #category : #tests }
ProcessMonitorTestServiceTest >> testResumeFailedProcessesWhenHaltIsSignaledInBackground [
	| processWithHalt executed |
	executed := false.
	self fork: [ testService suspendBackgroundFailure: Error new. executed := true ].
	processWithHalt := self fork: [ Processor activeProcess suspend. Halt new signal ].
	
	processWithHalt on: Halt do: [ :actual | ].
	processWithHalt resume.
	
	self assert: executed.
	self deny: testService shouldSuspendBackgroundFailures
]

{ #category : #tests }
ProcessMonitorTestServiceTest >> testResumeFailedProcessesWhenTestFailureIsUnhandled [
	| executed |
	executed := false.
	self fork: [ testService suspendBackgroundFailure: Error new. executed := true ].
	self deny: executed.	

	testService handleException: Error new. "UnhandledError always started with original error signal"
	testService handleException: UnhandledError new.
	self assert: executed.
	"Unhandled exception opens debugger and therefore any new errors should not be suspended"
	self deny: testService shouldSuspendBackgroundFailures 
]

{ #category : #tests }
ProcessMonitorTestServiceTest >> testShouldSuspendBackgroundFailuresByDefault [

	self assert: testService shouldSuspendBackgroundFailures 
]

{ #category : #tests }
ProcessMonitorTestServiceTest >> testStoreAllForkedProcesses [

	| process |
	process := self fork: [ ].
	
	self assert: (testService forkedProcesses includes: process)
]

{ #category : #tests }
ProcessMonitorTestServiceTest >> testSuspendBackgroundError [

	| process error suspendedError |
	error := Error new messageText: 'test error'.
	
	process := self fork: [ error signal ].
	
	self assert: process isSuspended.
	suspendedError := testService suspendedBackgroundFailures at: process.
	self assert: suspendedError class equals: UnhandledError. 
	self assert: suspendedError exception identicalTo: error.
]

{ #category : #tests }
ProcessMonitorTestServiceTest >> testSuspendBackgroundWarning [
	
	| process warning suspendedError |
	warning := Warning new.
	process := self fork: [ warning signal ].
	
	self assert: process isSuspended.
	suspendedError := testService suspendedBackgroundFailures at: process.
	self assert: suspendedError class equals: UnhandledError. 
	self assert: suspendedError exception identicalTo: warning.
]

{ #category : #tests }
ProcessMonitorTestServiceTest >> testSuspendResumeTerminateIssue [
	"The test discovers the issue with Process>>isTerminated method
	when process was suspended in the middle and then resumed.
	During the bootstrap process on CI it fails RunKernelTests stage.
	But it is working on full image"
	| process ended started |
	ended := false.
	started := false.
	process := [ started := true. Processor activeProcess suspend. ended := true ] newProcess.
	process priority: Processor activePriority + 1.
	processes add: process.	
	process resume.
	self assert: started description: 'process should be started'.
	self assert: process isSuspended description: 'process should be suspended'.

	process resume.
	self assert: ended description: 'process should be ended'.
	self assert: process isTerminated description: 'process should be terminated'
]

{ #category : #tests }
ProcessMonitorTestServiceTest >> testSuspendResumeTerminateIssueWithoutSuspend [
	"The test proves that suspend at the middle is required condition to trigger the issue.
	Here the suspend is not performed and test passes on every CI stage.
	(notice that #printString call here is to have equivalent message send like #suspend)"	
	| process ended started |
	ended := false.
	started := false.
	process := [ started := true. self printString. ended := true ] newProcess.
	process priority: Processor activePriority + 1.
	processes add: process.	
	process resume.
	self assert: started description: 'process should be started'.
	self assert: ended description: 'process should be ended'.
	self assert: process isTerminated description: 'process should be terminated'
]
